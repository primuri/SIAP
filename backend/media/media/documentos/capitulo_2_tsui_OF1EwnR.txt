2.1 Características de la construcción de un sistema
El capítulo anterior se centraba en el entorno y las condiciones en las que una sola persona puede desarrollar un programa para unos pocos usuarios.
programa puede ser desarrollado por una persona para, quizás, sólo unos pocos usuarios. Ya hemos visto
Ya hemos visto múltiples elementos que deben tenerse en cuenta incluso cuando una persona está escribiendo un único
programa. En este capítulo describiremos los problemas e inquietudes asociados con la construcción de un sistema que contenga múltiples componentes -cualquier cosa desde unos pocos componentes
hasta cientos o miles de componentes. El aumento en el número de componentes
y complejidad es lo que requiere que estudiemos y entendamos los varios aspectos, principios,
y técnicas de ingeniería de software que se discutirán en los capítulos posteriores. En
Esta discusión introduce los fundamentos de la ingeniería de software como disciplina, especialmente para
proyectos grandes y complejos que requieren un equipo de personas.
2.1.1 Tamaño y complejidad
A medida que el software se vuelve omnipresente, el desarrollo de sistemas con software también se vuelve más complejo.
es cada vez más complejo. A los ingenieros de software se les pide que resuelvan tanto problemas sencillos como complejos
simples y complejos, así como las diferencias entre ellos. Los problemas complejos
se presentan en varios niveles de amplitud y profundidad. El problema de la amplitud se refiere a
números que implican lo siguiente:
Funciones principales
Características de cada área funcional
Interfaces con otros sistemas externos
Usuarios simultáneos
Tipos de datos y estructuras de datos
La cuestión de la profundidad aborda la vinculación y las relaciones entre los elementos. Los vínculos
pueden consistir en compartir datos, transferir control o ambas cosas.
Estas relaciones pueden ser jerárquicas, secuenciales, en bucle, recursivas o de otro tipo.
Al desarrollar soluciones a estos complejos problemas, los ingenieros de software deben diseñar con
posiblemente otro conjunto de relaciones diferente al del problema. La figura 2.1
muestra el efecto de introducir tanto (1) el tamaño en términos de amplitud como (2) la complejidad en términos de profundidad y número de interacciones. Aunque se puede tener una "sensación" natural de
la diferencia con sólo ver el diagrama, merecería la pena dedicar tiempo a analizar
las diferencias. El caso sencillo de esta figura tiene tres segmentos principales: (1) iniciar el proceso,
(2) realizar tres tareas normales, y (3) detener el proceso. En la figura 2.1(b), el número de tareas normales
normales ha aumentado de tres a cinco con la adición de "esperar señal" y "realizar tarea A2".
tarea A2". También hay una nueva tarea de decisión, representada por la figura en forma de rombo en el
centro. La tarea de decisión ha aumentado considerablemente el número de caminos u opciones, y por lo tanto
provoca el aumento de la complejidad. Además, la complejidad se agrava aún más al
introduciendo una relación de bucle con la tarea de decisión. Hay muchas más interacciones
interacciones en una relación de bucle o repetición, que es más compleja que la relación secuencial directa entre las tareas representada en la figura.
entre las tareas representadas en la Figura 2.1(a).
Como se muestra en la figura 2.1, un aumento relativamente pequeño del número de tareas y decisiones
ha aumentado enormemente la complejidad. Como en el caso de un único módulo de programación, cuando
tanto el tamaño como la complejidad se magnifican varias veces en un problema de sistema de software, la
solución a esos problemas también implica una expansión comparable en tamaño y complejidad
2.1.2 Consideraciones técnicas de desarrollo y soporte
En los tres apartados siguientes trataremos una serie de cuestiones técnicas relacionadas con el desarrollo y el soporte de un sistema.
Descomposición del problema y el diseño Cuando pasamos de una situación sencilla a otra compleja
de construir sistemas de software, hay algunas cuestiones técnicas que debemos tener en cuenta. La
La cuestión básica es cómo manejar todas las piezas, partes y relaciones. Una solución común se
basada en el concepto de divide y vencerás. Esto tiene sus raíces en el concepto de modularización
presentado por primera vez por Parnas (1972). La modularización se tratará con más detalle en el capítulo 7. La
La pregunta natural -cómo dividimos un problema grande y complejo y su solución en partes más pequeñas- es más difícil de lo que parece.
es más difícil de lo que parece. Primero tenemos que simplificar el problema grande y complejo
abordando el problema en segmentos más pequeños. Una vez que hayamos
Después de haber completado con éxito ese proceso, nuestro siguiente paso es decidir si debemos diseñar y descomponer la solución del sistema de software a lo largo de las líneas divisorias.
solución del sistema de software a lo largo de las líneas divisorias de los segmentos del problema. Así, si la
la descripción del problema, o el requisito, se segmenta por función y característica, ¿debemos
la solución a lo largo de los mismos segmentos de función y característica?
Alternativamente, ¿deberíamos elegir otro método de descomposición para la solución, tal vez
¿en la línea de los "objetos"? (Para más información sobre los objetos, consúltese el capítulo 7.) La clave para abordar problemas grandes y complejos es la descomposición.
La clave para abordar problemas grandes y complejos es considerar alguna forma de simplificación
mediante los siguientes tipos de actividades:
Descomposición
Modularización
Separación
Iteraciones incrementales
Esta noción se amplía en la sección 2.2.2, que trata del diseño de un sistema de nóminas.
de nóminas.
Consideraciones sobre tecnología y herramientas Aparte de la importante cuestión de descomponer un
problema y su solución, existen problemas relacionados con la tecnología y las herramientas
que también habrá que abordar. Si no está escribiendo un programa sólo para un conjunto limitado
de usuarios, la elección del lenguaje de programación específico puede convertirse en un problema. Un sistema
Un sistema grande y complejo requiere más de una persona para desarrollar la solución de software. Aunque todos
Si bien todos los desarrolladores implicados pueden conocer varios lenguajes, cada persona suele tener una experiencia diferente.
experiencia diferente. Esta diversidad en la formación y la experiencia suele dar lugar a prejuicios personales a favor o en contra de un determinado lenguaje de programación y de la elección del lenguaje de desarrollo.
a favor o en contra de un determinado lenguaje de programación y de la elección de la herramienta de desarrollo.
de desarrollo. Es necesario elegir un lenguaje y un entorno de desarrollo comunes.
común. Más allá del lenguaje de programación y las herramientas de desarrollo, hay otras
otras opciones técnicas relacionadas con lo siguiente:
Base de datos
Red
Middleware
Otros componentes técnicos, como el control de versiones del código.
Deben ser acordados por todas las partes implicadas en la creación y el soporte de un sistema de software complejo.
complejo de software.
Proceso y metodología Ya hemos aludido a la metodología y el proceso al hablar de la necesidad de simplificación y descomposición.
la necesidad de simplificación y descomposición. Cuando sólo hay una persona
que desarrolla la solución, sigue siendo necesario comprender el problema o los requisitos.
A menudo es necesario tomarse el tiempo necesario para elaborar o diseñar la solución y luego
implementarla. La prueba de la solución puede ser realizada por la misma persona y,
posiblemente, con un usuario. En tales condiciones, hay muy poca comunicación entre
personas. Ningún material, como un documento de diseño, pasa del autor a otra persona.
persona. Aún así, puede ser necesario documentar el trabajo realizado porque incluso un único
desarrollador olvida algunos de los fundamentos de las decisiones tomadas. Normalmente no hay
necesidad de coordinar los elementos de trabajo porque puede que no haya muchas partes. La metodología
La metodología específica utilizada para realizar cualquiera de las tareas no necesita coordinarse cuando sólo participan una o dos personas.
sólo participan una o dos personas.
En una situación de desarrollo grande y compleja, el problema se descompone y lo trabajan muchos expertos diferentes.
muchos expertos diferentes. Se necesita un proceso de desarrollo de software para guiar y
coordinar al grupo de personas. Los elementos sencillos, como la sintaxis para la expresión de un
diseño, necesita un acuerdo entre todos los desarrolladores para que todos puedan revisar, comprender,
y producir un diseño coherente y cohesivo. Cada método utilizado para una tarea específica
junto con todo el proceso de desarrollo, debe ser consensuado por
el grupo de personas implicadas en el proyecto. El desarrollo de software
se inventaron para coordinar y gestionar proyectos complejos en los que
proyectos complejos en los que participan muchas personas. El proceso se facilita enormemente cuando un grupo de personas puede convertirse en un equipo de individuos que cooperan.
equipo de individuos. Aunque las mejoras continuas y los nuevos


NOTA
Proceso de desarrollo de software El conjunto de
tareas, la secuencia y el flujo de estas tareas,
las entradas y salidas de las tareas,
y las condiciones previas y posteriores para
cada una de las tareas implicadas en la producción
de un programa informático. (2.1.2)

se hacen constantemente propuestas, nadie ha propuesto aún la eliminación completa
del proceso o la metodología. Independientemente de lo que se crea sobre los procesos de software, es
proceso debe existir para ayudar a coordinar un proyecto de software complejo y
un proyecto de software complejo y satisfactorio. Los modelos de procesos de software tradicionales y los
Los modelos de procesos de software tradicionales y los emergentes, incluidos los populares métodos ágiles, se tratarán en los capítulos 4 y 5.
Consideremos el sencillo escenario de representar las seis tareas principales que se muestran en la Figura 2.2. Estas
son las tareas comunes que se realizan a menudo en el desarrollo y soporte de software. Cada tarea
Cada tarea aparece como un elemento independiente, y cada una plantea la pregunta de qué se espera de ella y cómo se lleva a cabo.
y cómo llevarlas a cabo. Por ejemplo, ¿existe una metodología para reunir los requisitos?
Si la tarea de recopilación de requisitos la realiza más de una persona, habrá que determinar cómo
hay que definir cómo debe dividirse esa tarea. Del mismo modo, cabe preguntarse
asistencia al usuario y qué problemas deben solucionarse.
Las tareas de la figura 2.2 se presentan de forma independiente. Cuando varias personas
Cuando hay varias personas implicadas en el desarrollo y el soporte de software, debe haber una clara comprensión de la secuencia, el solapamiento y el punto de partida.
la secuencia, el solapamiento y las condiciones de partida. Por ejemplo, los diseñadores y codificadores pueden
ser un grupo de personas diferente de los analistas de requisitos que trabajan con los clientes. ¿En qué momento deben empezar sus tareas los diseñadores y codificadores?
¿Hasta qué punto pueden solaparse estas tareas? ¿Cómo debe integrarse y probarse el código
y probado? La definición del proceso debe responder a estas preguntas y ayudar a coordinar
coordinar las distintas tareas y garantizar que se lleven a cabo según las metodologías
previamente acordadas.
La figura 2.3 representa un enfoque que emplea el concepto de desarrollo incremental e integración continua. La integración de software es el proceso de unir
unidades probadas individualmente en un sistema completo coordinado. La integración continua
se practica desde los años 70, cuando se empezaron a construir grandes sistemas (Tsui y Priven,
1976). Recientemente, debido al uso generalizado del desarrollo incremental y las metodologías Agile
la integración continua está ganando popularidad general. Todas las metodologías implicadas en el desarrollo incremental deben ser acordadas y practicadas por todo el equipo de desarrollo.
todo el equipo de desarrollo. Las aparentemente sencillas casillas que representan el método prueba-fijación-integración 

.de la figura 2.3 son extremadamente engañosas. Ese sencillo ciclo requiere la descripción de una
metodología que responda a las siguientes preguntas:
¿Existe un grupo de pruebas separado e independiente?
Cuando se detecta un problema, ¿cómo y a quién debe notificarse?
¿Cuánta información debe acompañar a la descripción de un problema?
¿Quién decide el nivel de gravedad de un problema?
¿Cómo se devuelve un problema corregido al evaluador?
¿Deben volver a probarse todas las correcciones?
¿Cómo se integran las correcciones en el código?
¿Qué hacer con los problemas que no se solucionan?
Éstas son sólo algunas de las cuestiones que deben determinarse y resolverse para una parte
del proceso representado en la figura 2.3. En los Capítulos 2.3. y 2.4. ampliaremos los detalles relativos a las metodologías y procesos de prueba e integración.
de pruebas e integración en los capítulos 10 y 11. El proceso también presupone
que se utiliza el desarrollo incremental y que tanto el problema como el diseño pueden
descomponerse en incrementos. La figura 2.3 no incluye las actividades de soporte y
las actividades de soporte y solución de problemas del cliente. No hay que olvidar que los productos de software necesitan soporte de uso,
correcciones y mejoras. El proceso desempeña un papel vital en la definición y coordinación de las actividades de desarrollo de sistemas grandes y complejos.
las actividades de desarrollo y soporte de sistemas grandes y complejos.

2.1.3 Consideraciones no técnicas del desarrollo y el soporte
Además de las implicaciones técnicas, los sistemas grandes y complejos también requieren un conocimiento
cuestiones no técnicas. Aquí trataremos dos de ellas.
Estimación del esfuerzo y calendario Para un proyecto de software pequeño y bastante sencillo que
de una a tres personas, la estimación del esfuerzo y la programación del proyecto son relativamente sencillas.
del proyecto es relativamente fácil. Tanto los requisitos funcionales como los no funcionales del proyecto son menos numerosos y complejos.
del proyecto son menos numerosos y complejos. Aun así, como se ha visto en el capítulo 1
sigue sin ser una tarea trivial. En el caso de sistemas grandes y complejos, capturar y comprender
de los requisitos puede resultar abrumadora. Estimar el esfuerzo total y elaborar
en estas difíciles condiciones es una de las principales razones del fracaso de muchos proyectos de software.
de tantos fracasos de proyectos de software; véase Jorgensen (2004) para más detalles. En
Las estimaciones de esfuerzo y los calendarios imprecisos para sistemas grandes y complejos suelen ser extremadamente optimistas y agresivos.
optimistas y agresivos, lo que crea expectativas poco realistas tanto en los clientes como en los proveedores de estos sistemas.
los proveedores de estos sistemas.
Como ejemplo, consideremos un proyecto de software relativamente sencillo que requiere tres funciones principales con un total de 12 características.
funciones con un total de 12 características. La estimación del esfuerzo de este proyecto  requiere un buen
todas las características funcionales y la productividad de los miembros del pequeño
pequeño equipo que trabajará en esas 12 funciones. Para un sistema de software grande y complejo
el número de funciones principales suele ser de decenas o centenares. El número total de características
dentro de estas funciones principales puede ser fácilmente de cientos y miles. El número
de personas necesarias para desarrollar un sistema de este tipo puede ser fácilmente de cientos. En estas
circunstancias, la probabilidad de comprender bien todos los requisitos y de conocer
la productividad de todas las personas es muy baja. La ordenación del número de
combinaciones de individuos asignados al diseño y codificación de un número tan grande de
puede ser una tarea de enormes proporciones. La estimación del esfuerzo resultante y el calendario
a menudo una buena "suposición" y dista mucho de ser exacta. La industria del software ha reconocido
este problema y se ha enfrentado a él. En el capítulo 13 abordaremos algunas
técnicas que se han desarrollado y que ya están disponibles.
Asignaciones y comunicaciones Hemos tratado el problema de la asignación de personas
para diseñar y codificar las diferentes características funcionales cuando el número de características
y el número correspondiente de desarrolladores aumenta. Además
Además, hay otras actividades que requieren recursos humanos. La asignación de diferentes personas a
diferentes tareas, como las pruebas, la integración o el soporte de herramientas, requiere una mayor comprensión de
las competencias de las personas implicadas y las tareas específicas que deben realizar. La asignación
de las personas más eficaces y cualificadas a las tareas adecuadas requiere un mayor nivel de
de granularidad y un nivel más fino de programación.
Otro problema relacionado con el aumento de personal es el de las comunicaciones. En un proyecto pequeño en el que participen dos o tres personas, el número de vías de comunicación es de una entre dos personas y de tres entre tres.
comunicaciones es de una entre dos personas y de tres entre tres personas. La figura 2.4 ilustra
cómo aumenta el número máximo de vías de comunicación a medida que aumenta el número de participantes. Los nodos
Los nodos de esta figura representan a las personas y las líneas, las vías de comunicación.
El número de posibles vías de comunicación se duplicó con creces cuando el número de miembros del equipo pasó de cuatro a seis.
miembros del equipo pasó de cuatro a seis.
En general, el número de vías de comunicación para n personas es SUM(n-1), donde SUM es
la función de suma aritmética de 1, 2, ..., n. Por tanto, un modesto aumento de un equipo de cuatro personas a uno de doce duplicaría el número de posibles vías de comunicación.
a un equipo de doce personas aumentaría el número potencial de vías de
de comunicación de 6 a 66. La triplicación de un equipo pequeño multiplicaría por más de diez las posibles vías de comunicación.
de comunicación en más de diez veces.
Asociado a este aumento en el número de vías de comunicación está la posibilidad de que se produzca un error en las comunicaciones.
de error en las comunicaciones. Consideremos, por ejemplo, que la probabilidad de comunicar
correctamente un determinado mensaje entre dos personas cualesquiera es de 2/3. La probabilidad de que
comunicar correctamente de una persona a otra y luego de esa segunda persona a
una tercera persona sería (2/3 × 2/3) = 4/9. En general, para n personas donde n es igual o superior a 2
la probabilidad de comunicar correctamente este mensaje sería (2/3)n-1. Por tanto, para este
mensaje, sólo hay una probabilidad de 16/81 de transmitirlo correctamente de la primera persona a la quinta del equipo.
persona del equipo. De repente, hemos reducido una probabilidad de 2/3 de comunicar correctamente un mensaje a menos de 1/4.
un mensaje a menos de 1/4. Una probabilidad tan baja de comunicación correcta entre los miembros del equipo
puede ser un problema grave, sobre todo si el mensaje es crítico. Organización
para reducir la complejidad y aumentar la probabilidad de una comunicación correcta.
probabilidad de comunicaciones correctas.
2.2 Construcción de un sistema hipotético
En este apartado utilizaremos un sistema hipotético de nóminas para ilustrar algunos de los problemas
introducidos en el apartado 2.1. En este apartado se tratarán las principales tareas que conlleva el desarrollo de un sistema de este tipo y el soporte del mismo una vez implantado.
de desarrollar un sistema de este tipo y de dar soporte al sistema una vez puesto a disposición de los usuarios. La intención de esta sección
La intención de esta sección es proporcionar sólo una visión de los diferentes problemas y preocupaciones que surgen en la construcción de nuestro sistema, pero no ahondar en el tema.
nuestro sistema, pero no profundizar en todos los detalles de la construcción y el soporte de este sistema.
2.2.1 Requisitos del sistema de nóminas
Todo el mundo tiene una idea de lo que es un sistema de nóminas. Tómese un momento para pensar
los principales requisitos funcionales y no funcionales de un sistema de nóminas.
de un sistema de nómina. Las siguientes capacidades funcionales representan sólo algunas de las tareas que debe poder realizar un sistema de nóminas. Esta lista está muy lejos de lo que un verdadero sistema de nóminas
necesitaría.
Añadir, modificar y borrar los nombres y la información personal asociada de todos los empleados.
Añadir, modificar y borrar todos los beneficios asociados a todos los empleados.
Añadir, modificar y eliminar todos los impuestos y otras deducciones asociadas a todos los empleados.
Añadir, modificar y eliminar todos los ingresos brutos asociados a todos los empleados.
Añadir, modificar y eliminar todos los algoritmos relacionados con el cálculo del salario neto de cada empleado.
empleado.
Generar un cheque en papel o un ingreso bancario directo electrónico para cada empleado.
Cada uno de estos requisitos funcionales puede ampliarse a varios niveles de más detalle. Por ejemplo, sólo para el primer elemento de nombres e información personal asociada, uno
la información asociada. Es una pregunta sencilla,
pero requeriría que el ingeniero de software solicitara información al respecto. ¿Dónde y a quién
¿Dónde y a quién? ¿Debería preguntar a los usuarios, a alguna persona
o al jefe de proyecto? Una vez respondida la pregunta, ¿debería
documentarse la respuesta? El siguiente requisito funcional de la lista anterior habla
a todas las ventajas. ¿Qué son todas las prestaciones? ¿Qué significa tener una prestación en la nómina de un empleado? ¿Existe una lista de todas las prestaciones posibles? No hace falta mucho para darse cuenta de que
la solicitud de requisitos, la recopilación, la documentación, el análisis y la validación de un sistema de nóminas
sistema de nóminas requerirá un esfuerzo considerable. Para gestionar adecuadamente la parte de aplicación de
los requisitos del sistema de nóminas, es posible que necesitemos comprender algo sobre los beneficios,
leyes fiscales y otros conocimientos específicos del sector.
Además, el sistema de nóminas debe ser capaz de generar las nóminas y los depósitos directos varias veces al mes.
varias veces al mes. ¿Cuál es el ciclo de nóminas admisible? En otras palabras, si
En otras palabras, si los cheques y depósitos deben completarse a mediados y finales de mes, ¿cuándo
deben cerrarse las entradas al ciclo, como el aumento salarial? Aquí nos interesa
la ventana del ciclo de procesamiento de nóminas que es permisible en el entorno
y qué capacidad de rendimiento debe tener el sistema para satisfacer esa ventana de procesamiento. Esto implica el requisito no funcional de rendimiento introducido en el apartado 1.1.2.
en el apartado 1.1.2. La respuesta a esta pregunta requerirá que el ingeniero de software conozca
el volumen de transacciones de nómina y la velocidad de procesamiento de cada transacción de nómina.
Para analizar y tratar este tipo de requisito, es posible que necesitemos conocer el hardware y
capacidad del entorno del sistema operativo sobre el que se ejecutará el sistema de nóminas. Algunos de los requisitos del sistema de nóminas requerirán, además del conocimiento del ámbito de las nóminas
el conocimiento de la información técnica del sistema y de la interfaz.
También es necesario comprender cómo funciona el proceso real de ejecución de la nómina
en el sitio del usuario/cliente. Por ejemplo, si hay un registro incorrecto, ¿cómo debe reprocesarse la nómina de esa persona?
de esa persona? ¿Implica esto que hay que volver a ejecutar el sistema de nóminas varias veces?
varias veces? Debe abordarse el requisito no funcional de la seguridad.
¿Qué protección se necesita ante un posible error, malicia o casualidad? Puede
También puede haber algunos requisitos que los usuarios/clientes ni siquiera se acuerden de proporcionar
inicialmente. En el capítulo 6 se analiza cómo podemos gestionar estos requisitos tardíos.
Una vez documentada la información sobre los requisitos de un sistema de nóminas, lo más probable es que la complejidad
de dicho sistema requerirá probablemente una revisión con los usuarios/clientes antes de que la especificación de requisitos pase a la fase de diseño y codificación.
Estas revisiones pueden realizarse gradualmente a medida que los requisitos se analizan y documentan
y documentados, o de una sola vez, cuando se analizan y especifican todos los requisitos a la vez. Cualquiera de las dos situaciones requerirá una coordinación de esfuerzos entre los usuarios/clientes
y los analistas de requisitos.
Así pues, está claro que el número total de actividades necesarias para completar la fase de requisitos de un sistema de nóminas
la fase de requisitos por sí sola puede ser extremadamente alta, además de requerir mucho tiempo. La fase de requisitos es fundamental para el éxito del sistema. No basta con un único analista de requisitos, sino
de requisitos, sino un equipo de analistas de requisitos, es decir, personas con diversos
desde conocimientos específicos del ámbito de la nómina hasta experiencia en TI y desarrollo de sistemas.
sistemas. Desde el punto de vista de la calidad, Jones (1992) también ha señalado que
aproximadamente el 15% de los defectos de software se deben a errores en los requisitos. Las actividades relacionadas con la especificación de los requisitos de un sistema, como el de nuestro ejemplo de la nómina, son difíciles y tienen un impacto significativo en la calidad del servicio.
ejemplo, son difíciles y tienen un impacto significativo en todas las actividades posteriores y en el producto final.
producto final. Se han escrito libros completos sobre este tema. (Véase la sección Referencias y lecturas sugeridas al final de este capítulo).
2.2.2 Diseño del sistema de nóminas
Una vez que se han entendido y acordado los requisitos del sistema de nóminas, hay que diseñarlo.
debe diseñarse. Dejando a un lado el hecho de que los requisitos del sistema de nóminas expresados
en el apartado 2.2.1 son sólo un ejemplo y están incompletos. Por ejemplo
preguntarnos si todos los requisitos funcionales de "añadir, actualizar y eliminar" deberían agruparse
en un único componente llamado "funciones administrativas de la nómina". A continuación, podríamos
preguntarnos si todas las funciones de procesamiento, como el cálculo de todas las deducciones y del
importe neto de la paga deben agruparse en un componente llamado "procesamiento de nóminas".
Ciertamente, debemos estar preparados para gestionar errores y excepciones. Así pues, las funciones que se ocupan
con el tratamiento de errores y excepciones pueden agruparse en un componente de tratamiento de excepciones
de excepciones. Además, el sistema de nóminas debe interactuar con sistemas externos como
depósitos bancarios directos o transmisiones por lotes a sitios remotos para la impresión local de cheques. En
puede decidir colocar todas las funciones de interfaz en un componente llamado "interfaces de nómina".
Esta agrupación de funciones relacionadas en componentes tiene varias ventajas:
Proporciona cierta cohesión de diseño dentro del componente
Se ajusta al flujo de negocio y al entorno de procesamiento de nóminas
Ofrece una posible asignación del trabajo por componentes
Permite empaquetar más fácilmente el software por componentes
Este enfoque puede presentar algunos inconvenientes. Es concebible que todavía haya fuertes
o acoplamiento entre estos componentes. En este caso, el acoplamiento puede deberse a
el uso extensivo de un archivo de datos común o de una tabla común en una base de datos relacional. Incluso a
Incluso a este alto nivel, los diseñadores deben tener en cuenta las características de cohesión y acoplamiento del diseño.
y el acoplamiento. Los conceptos relacionados con estos temas se tratan ampliamente en el capítulo 8.
También hay necesidades específicas no funcionales, pero de servicio común, que deben diseñarse.
Por ejemplo, el servicio de ayuda o el servicio de mensajes deben diseñarse para todos los componentes funcionales. Estos servicios pueden colocarse todos en un componente llamado componente de servicios. La combinación de componentes funcionales y servicios comunes se muestra en la
Figura 2.5 como entidades de diseño horizontales y verticales. Las entidades horizontales son las funciones de servicio comunes, como el gestor de errores, que atraviesan todas las funciones individuales de la aplicación.
individuales de la aplicación. Las entidades verticales son las diferentes funciones específicas del dominio de la aplicación, como la función de deducción de impuestos y prestaciones.
como la función de deducción de impuestos y prestaciones en un sistema de nóminas. La interacción, o acoplamiento
de los diversos componentes funcionales con estos servicios comunes es una preocupación clave del diseño.
Es durante el diseño cuando se finaliza la disposición de la interfaz de pantalla. En el caso de un sistema
En el caso de un sistema de nóminas, se trata de un sistema muy orientado a los lotes, más que de un sistema interactivo. Por lo tanto, la interfaz de usuario en términos de arquitectura de pantalla no es una preocupación principal de diseño. No obstante
Sin embargo, hay que tenerla en cuenta. Las tablas de la base de datos y las claves de búsqueda, sin embargo, son importantes y
para una gran aplicación de procesamiento por lotes.
Aunque hay muchas formas de realizar un diseño de alto nivel y detallado, el diseño
de un sistema de nóminas requiere un amplio conjunto de conocimientos debido a la amplitud y profundidad del sistema.
del sistema. Desde el punto de vista de la amplitud, las habilidades de diseño necesarias requieren conocimientos complejos:
interfaces de base de datos, red y transmisión; interfaces de impresión; interfaces de sistema operativo; entorno de herramientas de desarrollo; y el dominio de la aplicación de nóminas. Desde la perspectiva de la profundidad
profundidad, el diseñador debe comprender y apreciar las particularidades de un
como el rendimiento y el tratamiento de errores. Aunque se trata de un sistema de procesamiento por lotes, el gran volumen de registros de nóminas de las grandes empresas suele requerir un diseño especial.
de errores en una tarea compleja.
compleja. El diseño no sólo debe captar la información errónea o contradictoria, sino que
también debe tener en cuenta qué debe ocurrir con las personas cuyos registros no pueden procesarse.
Si estos registros no se tratan inmediatamente y se deja que se acumulen hasta el final de
no hay tiempo para reaccionar. Estos registros deben tratarse de modo que puedan
puedan convertirse en nómina dentro del ciclo de procesamiento de la nómina. El diseñador debe tener en cuenta
el entorno de nómina y la posibilidad de tener que codificar a mano los cheques de pago para un
pequeño número de desafortunados. Así pues, el diseñador debe concebir el sistema de modo que incluya
salidas de procesamiento manual del sistema y la conciliación de estos registros procesados manualmente
en el sistema automatizado de nóminas. La profundidad del procesamiento de errores en un gran
La profundidad del procesamiento de errores en un gran sistema como el de nóminas puede ser un reto incluso para los diseñadores más experimentados.
El diseño de la nómina mencionado aquí utiliza técnicas de descomposición funcional y síntesis dentro de cada uno de los componentes.
dentro de cada uno de los componentes. Además de las interacciones entre componentes,
Además de las interacciones intercomponentes, las distintas piezas de un componente deben dividirse claramente y la interacción intracomponente entre las piezas también debe diseñarse.
entre las piezas. Está claro que diseñar un sistema complejo
es muy diferente del diseño de un único módulo de programación y requerirá una mayor
disciplina y principios rectores adicionales, así como la posibilidad de contar con varios miembros más del equipo.
miembros del equipo.
2.2.3 Codificación y pruebas unitarias del sistema de nóminas
El diseño o la arquitectura de alto nivel del sistema de nóminas debe perfeccionarse y convertirse en código ejecutable.
convertirse en código ejecutable. Dentro de cada componente de diseño, la unidad funcional individual, interactiva,
unidad funcional que interactúa debe diseñarse y convertirse en código. Esta actividad es familiar para
la mayoría de las personas que entran en el campo de la informática. El primer curso que se suele impartir a los estudiantes de ingeniería de software o informática consiste en un pequeño problema que debe resolverse con un diseño funcional detallado.
debe resolverse con un diseño funcional detallado y código. A veces, cuando la solución
es lo bastante pequeña, ni siquiera se registra el diseño detallado y sólo se dispone del código fuente del
del módulo.
Para cada una de las unidades funcionales, el programador debe abordar y desarrollar el siguiente material:
Diseño preciso de la interfaz de pantalla en algún lenguaje
Lógica precisa de procesamiento funcional en algún lenguaje de programación
Lógica precisa de acceso y almacenamiento de datos en algún lenguaje
Lógica de interfaz precisa en algún lenguaje
Además, si hay muchas de estas unidades de programación, deben establecerse algunas normas comunes.
comunes. Un ejemplo sería una convención de nomenclatura para cada uno de los módulos que
identificaría de forma única a cada uno como el módulo de un componente específico. También
de base de datos, de forma que todos los elementos de una tabla relacional específica tengan el mismo prefijo.
tabla relacional específica tengan el mismo prefijo. Puede que haya que establecer convenciones para documentar algunos de
el diseño detallado, como proporcionar comentarios sobre las condiciones en las que se puede entrar y salir de este módulo.
se puede entrar y salir de este módulo. Los comentarios también pueden describir los datos que son vitales para el
procesamiento y una breve descripción de la función prevista. Una parte muy importante es el
diseño, el código y la documentación sobre cómo tratar las distintas condiciones de error. Los
Los mensajes de error mostrados por los distintos módulos del programa deben ser coherentes.
cada unidad de programa debe seguir el estándar de mensajes de error.
Una vez completado el módulo de programa, la persona que haya realizado la tarea deberá probar el módulo para confirmar que se ha realizado correctamente.
debe probar el módulo para confirmar que realiza las tareas previstas. El primer paso
en esta tarea de prueba de la unidad es establecer las condiciones del módulo y elegir los datos de entrada adecuados. El siguiente paso consiste en ejecutar o poner en marcha el módulo y observar su comportamiento.
del módulo, principalmente mediante la comprobación de la salida del módulo, para asegurarse de que realiza lo que está previsto que haga. Por último, si se descubre algún problema
pruebas unitarias, hay que corregirlo y volver a probarlo. Una vez solucionados todos los problemas, el módulo está
está listo para integrarse en una unidad mayor, como una unidad funcional, o en un componente si el propio módulo es una unidad funcional.
componente si el propio módulo es una unidad funcional.
La programación o codificación y las pruebas unitarias de un módulo suelen correr a cargo de una sola persona.
persona. En un sistema grande, como un sistema de nóminas, puede haber cientos de módulos
que deben codificarse y probarse. Por lo tanto, la programación es una actividad
humanos. Cuando el número de programadores aumenta, la coordinación y la integración de todos los esfuerzos de programación se convierten en un problema.
la coordinación e integración de todos los esfuerzos de programación se convierte en un reto de gestión. Una vez más, hay que recurrir a los principios de gestión de la ingeniería de software para paliar la situación.
para aliviar la situación.
2.2.4 Integración y pruebas funcionales del sistema de nóminas
A medida que los módulos se completan y se prueban por unidades, deben recogerse formalmente de los programadores individuales.
programadores individuales. La actividad de recopilación se conoce como integración, que forma parte de
un mecanismo de control más amplio conocido como gestión de la configuración. La gestión de la configuración se mencionará a lo largo de este texto, pero se tratará formalmente en el capítulo 11.
Una razón sencilla para el paso de integración es que si los módulos terminados se dejan en manos de los
programadores individuales, éstos tienden a hacer cambios en un módulo ya probado
y confundirse sobre cuál es la última versión. Para garantizar que los
últimos módulos probados unitariamente funcionen juntos como una unidad funcional, estos módulos deben compilarse y enlazarse entre sí.
deben compilarse y enlazarse juntos. 
Una unidad funcional, en el caso del sistema de nóminas, puede
ser una parte del componente administrativo anteriormente mencionado que realiza las funciones de añadir,
modificar y eliminar todas las leyes federales de deducción, que casi siempre cambian
anualmente. A continuación, el conjunto integrado de módulos se prueba con casos de prueba funcionales generados
por un grupo más objetivo que los programadores que codificaron los módulos.
Las pruebas funcionales suelen descubrir algunos problemas que los programadores tendrán que solucionar. El ciclo de detección y corrección de problemas debe coordinarse entre
entre los probadores y los encargados de corregir el código. El código corregido debe integrarse en la unidad funcional y
volver a probarse para garantizar que todas las correcciones en grupo no se han afectado negativamente entre sí.
A medida que un conjunto de módulos de una unidad funcional completa la prueba funcional, se etiqueta electrónicamente como tal y se bloquea para que no se pueda utilizar.
etiquetado electrónicamente como tal y se bloquea para evitar más cambios. Estas unidades funcionales deben ser gestionadas por el mecanismo de gestión de la configuración, al igual que las unidades de módulos. En el caso
de uno o dos módulos, no hay mucha necesidad de un mecanismo de gestión de la integración y la configuración.
integración y gestión de la configuración. En la construcción de un sistema de software muy grande, como
como un sistema de nóminas, suele utilizarse una herramienta, como PVCS de Serena Software, para ayudar a automatizar el mecanismo de gestión de la configuración.
automatizar el mecanismo de gestión de la configuración. El personal y los conocimientos necesarios para
integración y las pruebas funcionales de un sistema de nóminas suelen ser diferentes de las necesarias para
las necesarias para la codificación, el diseño o la recopilación de requisitos. Sin embargo, los escenarios
y los guiones de prueba suelen requerir el conocimiento de los requisitos y el diseño.
2.2.5 Puesta en servicio del sistema de nóminas
Una vez probadas las unidades funcionales e integradas en componentes, estos componentes
componentes, estos componentes deben probarse conjuntamente para garantizar que el sistema completo funciona como un todo. Esto es importante para garantizar que todas las interfaces entre los componentes funcionan realmente. Además, las
componentes pueden afectar a otras unidades funcionales y componentes que ya funcionaban.
otras unidades funcionales y componentes que ya funcionaban. Incluso después de probar todo el sistema de nóminas
a través de todos los escenarios de usuario en el contexto del entorno empresarial del usuario, el sistema
a menos que no se encuentre ningún problema. Por lo menos, todos los problemas importantes deben solucionarse antes de que el sistema pueda ponerse a disposición de los usuarios. Una vez
Una vez más, el sistema de nóminas probado debe gestionarse y protegerse de futuros cambios.
Incluso si el sistema de nóminas está totalmente libre de errores, los usuarios deben ser educados en el uso del sistema, un proceso que para un gran sistema no puede ser una ocurrencia tardía y debe ser planificado y orquestado.
debe planificarse y orquestarse. La elaboración de material didáctico para un sistema
sistema no es una tarea trivial. Puede llevar varias personas y varios meses. En
La formación de los usuarios puede requerir competencias distintas a las del diseño técnico o la codificación.
El énfasis recaería en las habilidades de presentación y comunicación. Las personas que desarrollan
Las personas que desarrollan el contenido del material educativo pueden ser diferentes de las que imparten la formación.
Otra área de preparación antes de lanzar el sistema de nóminas sería la preparación del personal de apoyo al usuario. Es raro que los usuarios puedan dominar todos los detalles de un sistema de nóminas sólo a través de la formación.
de un sistema de nóminas sólo a través de la formación. Además, también es raro que un sistema grande y complejo esté totalmente libre de errores.
y complejo esté totalmente libre de errores. El propio personal de apoyo debe recibir una formación previa
sobre el sistema de nóminas, los entornos de usuario y las herramientas necesarias para prestar asistencia a los clientes.
Una vez que se ha completado la prueba del sistema, se ha formado a los usuarios y se ha establecido el grupo de soporte, el sistema de nóminas se pone en marcha.
el sistema de nóminas estará listo para su puesta a disposición de los usuarios. Quién
debe ser la persona que tome la decisión final sobre el lanzamiento de un producto? ¿Debe ser una
¿debe ser una decisión de grupo? ¿Y qué criterios debe utilizar esa persona para tomar la decisión?
liberación? Estos temas se engloban en la gestión de proyectos de software, que se tratará más
en el capítulo 13.
2.2.6 Soporte y mantenimiento
Para un producto de software pequeño, de uno o dos módulos y utilizado por pocas personas, el esfuerzo de soporte no es una preocupación importante.
el esfuerzo de soporte no es una preocupación importante. En el caso de un sistema de gran envergadura, como las nóminas, la asistencia posterior al lanzamiento de los usuarios y clientes puede ser muy importante.
de los usuarios y clientes puede ser un conjunto de tareas muy complejo. ¿A quién
cuando el sistema de nóminas se bloquea y aparece un mensaje con varias opciones posibles para el usuario.
mensaje con varias opciones posibles para el usuario antes de que el sistema de nóminas pueda seguir
el procesamiento? ¿A quién llama el usuario cuando la interfaz de depósito directo en el banco ha cambiado y la interfaz del sistema de nóminas existente tiene que cambiar?
bancaria ha cambiado y hay que modificar la interfaz existente del sistema de nóminas? ¿A quién
usuario cuando el sistema de nóminas muestra un problema de comportamiento diferente después de aplicar una
un problema anterior? Estas son sólo algunas de las muchas preguntas que surgirán después de que el
sistema de nóminas. 
Hay que hacer varias suposiciones e incluirlas en el
cálculo del esfuerzo previsto de apoyo al sistema de nóminas. Muchos de los siguientes factores
de decisión:
Número de usuarios y clientes previstos
Número y tipo de problemas conocidos que existían en el momento del lanzamiento
Número previsto de problemas que descubrirán los usuarios.
Cantidad de formación de los usuarios
Cantidad de formación del personal de apoyo
Cantidad de personal de desarrollo comprometido con el soporte del sistema
Número previsto de versiones de corrección de problemas y futuras versiones funcionales
Sobre la base de estos factores, debe estimarse y asignarse el número de personas necesarias
mantenimiento del sistema de nóminas. Se necesitarán competencias claramente diferenciadas
para dar soporte a un entorno tan complejo, y será necesario considerar
al menos dos grupos de personal de apoyo:
Un grupo para responder y gestionar el uso del sistema y las soluciones a problemas sencillos.
Un grupo para solucionar problemas difíciles e implantar futuras mejoras.
El primer grupo no tiene por qué incluir personal de codificación de programas. Sin embargo,
Sin embargo, deben poseer buenas dotes de comunicación, así como conocimientos sobre el uso y el sistema de nóminas.
nóminas. El segundo grupo suele incluir a diseñadores y programadores. Si se
Si se espera que el sistema de nóminas tenga una larga vida útil, el personal de apoyo debe estar preparado para varias versiones de mejoras funcionales.
debe estar preparado para varias versiones de mejoras funcionales. El personal de apoyo de este grupo
grupo puede asemejarse a un equipo de desarrollo completo. El concepto importante aquí
es que los sistemas grandes y complejos, como un sistema de nóminas, requerirán una organización de soporte que puede ser comparable en tamaño y complejidad al equipo de desarrollo original.
En el capítulo 12 se tratará con más detalle el tema del soporte y el mantenimiento posteriores a la publicación.
2.3 Esfuerzos de coordinación
El ejemplo de la nómina demuestra la necesidad de muchas de las actividades de ingeniería de software.
Una preocupación crítica para los sistemas grandes y complejos es la escala ascendente del proceso necesario,
de la estructura de diseño y contenidos del producto, y del personal necesario. En sentido
En la dirección opuesta se encuentra la preocupación por el escalado descendente de los mismos parámetros para sistemas más sencillos.
más sencillos. En esta sección presentaremos estas preocupaciones y trataremos los detalles del proceso,
el diseño del producto y la gestión del personal en capítulos posteriores.
2.3.1 Proceso
Ya hemos hablado de la noción de proceso. A medida que las aplicaciones y los sistemas
software se hicieron grandes y complejos en los años 80 y 90, el número de problemas graves y costosos se disparó.
problemas graves y costosos. A menudo, en el pasado, se ponían cada vez más trabas -generalmente en forma de
forma de más revisiones, más inspecciones, más pruebas y más reuniones.
como parte del proceso. Las grandes empresas se apuntaron a costosos esfuerzos de control y medición de la calidad. Estos esfuerzos se diseñaron para prevenir, detectar y corregir problemas, mejorando así la calidad del software.
problemas, mejorando así la calidad del software y aumentando la productividad de los
desarrolladores de software. Se pusieron en marcha amplios programas de medición de la calidad y la productividad.
productividad; véase el artículo sobre el programa de medición de Motorola de Daskalantonakis
(1992). Los procesos de desarrollo y soporte se orientaron hacia la aversión al riesgo.
aversión al riesgo. En los últimos años se ha producido un movimiento para simplificar el proceso, ya que la velocidad y el coste han empezado a ocupar un lugar central en el mercado.
en la industria del software (Beck y Andres, 2004; Cockburn,
2006). No existe un proceso único que se adapte a todas las ocasiones. Algunos son más apropiados para grandes
Algunos son más apropiados para sistemas grandes y complejos que requieren una amplia coordinación, y otros son mucho más sencillos y adecuados para proyectos de software pequeños y rápidos.
son apropiados para proyectos de software pequeños y rápidos. Trataremos el tema de los procesos
en detalle en los capítulos 4 y 5.
2.3.2 Producto
A menudo se piensa que un producto de software sólo contiene el código ejecutable. Sin embargo,
en el desarrollo y soporte de software, hay que producir muchos más artefactos, desde documentos de requisitos hasta escenarios de pruebas funcionales. Muchos usuarios
Muchos usuarios y clientes sofisticados necesitan manuales de usuario, formación de usuarios y asistencia técnica como parte del producto.
producto. En muchos casos, no basta con entregar un paquete de código ejecutable.
El sistema de nóminas considerado en este capítulo es un ejemplo de sistema en el que los clientes y usuarios exigirán mucho más que el código ejecutable. Además de los
artefactos necesarios para desarrollar el producto final, pueden pedir el documento de diseño
y el código fuente para que su personal pueda realizar futuras modificaciones. Por supuesto, una vez que el código fuente del producto haya sido modificado por los usuarios y clientes, esa parte del producto tendrá que ser revisada.
parte del producto tendrá que ser mantenida y soportada por los propios usuarios y clientes. El producto de software, grande o pequeño, que se espera que tenga una larga
vida útil, tendrá que estar diseñado para cambios y fácil mantenimiento. La coordinación
de los componentes y artefactos de software a lo largo de un periodo prolongado de cambios
actualizaciones y mantenimiento es una tarea compleja. Un gran producto de software puede
Un producto de software de gran tamaño puede diseñarse inicialmente para que tenga una gran cohesión funcional dentro de cada parte y un mínimo de interacciones o acoplamiento entre las partes. Es muy difícil mantener un alto grado de cohesión interna y un bajo nivel de acoplamiento.
cohesión interna y un bajo nivel de acoplamiento a medida que el gran producto de software evoluciona a través de muchos ciclos de modificaciones.
muchos ciclos de modificaciones. Un producto de software necesita estar protegido de la deriva del diseño
y la erosión (Taylor, Medvidovic y Dashofy, 2009). El diseño del producto de software
y la noción de cohesión y acoplamiento se tratarán con más detalle en los capítulos 7 y 8.
A medida que el diseño y el producto aumentan en complejidad, también lo hacen las pruebas. En
La coordinación de la preparación de las pruebas, las pruebas, la corrección y la integración se tratan con más detalle en los capítulos 9, 10 y 11.
2.3.3 Personas
Como ya ha demostrado el ejemplo del sistema de nóminas, para un gran sistema de software
necesitamos un equipo de personas con una gran variedad de habilidades y experiencia para desarrollar y apoyar el sistema.
desarrollar y mantener el sistema. El elemento humano es un componente crucial en el desarrollo y la
del software. En muchos sentidos, la industria del software sigue siendo intensiva en mano de obra. Por ello
estudio de la ingeniería de software debe incluir las cuestiones de coordinación de las actividades de las personas
y la capacidad de gestión.
Parte de la discusión sobre la coordinación de las actividades de los ingenieros de software está incluida en
del proceso. Una parte importante y vital de la coordinación del personal de software reside en
la estructura organizativa y la fuerza de las comunicaciones entre los diversos
grupos de interés. En el capítulo 13 se tratarán algunas cuestiones de gestión de personal relacionadas con las distintas fases de un proyecto de software.
diferentes fases de un proyecto de software.
2.4 Resumen
En este capítulo, hemos descrito el crecimiento en amplitud y profundidad de los problemas complejos de software y las soluciones de software asociadas.
problemas de software complejos y las soluciones de software asociadas. Se han presentado tanto las cuestiones técnicas como las no técnicas, desde la descomposición del diseño y las comunicaciones hasta el proceso, las herramientas y la metodología. Se utilizó un sistema de nóminas típico de una gran empresa como
como base para presentar y demostrar los problemas reales del desarrollo de grandes programas informáticos y de su mantenimiento. Los grandes proyectos de software requieren el control del
proceso, el producto y las personas implicadas. El campo de la ingeniería de software es vital para
el desarrollo y el soporte de estos sistemas grandes y complejos.
2.5 Preguntas de repaso
1. 1. Defina la cuestión de la profundidad frente a la amplitud en la complejidad del software.
2. 2. Describa una forma de simplificar un problema complejo.
3. Enumere dos preocupaciones técnicas en el desarrollo de grandes sistemas.
4. ¿Cuál es el número máximo de vías de comunicación para un equipo de veinte personas?
5. 5. Enumere cuatro factores que deben tenerse en cuenta para decidir cuántas personas
se necesitarán.
2.6 Ejercicios
1. (a) Ponga un ejemplo de aumento del tamaño del software. (b) Ponga un ejemplo de aumento
de la complejidad. (c) Comente qué tipo de aumento es, en su opinión, más difícil de
de gestionar.
2. 2. Analice la diferencia entre funciones verticales y horizontales y las posibles
interacciones entre ambos conjuntos.
3. 3. ¿Qué se entiende por integración y por qué es importante gestionarla en los grandes
sistemas?
4. 4. ¿Cuáles son las principales tareas de desarrollo y soporte de un sistema informático?
5. (a) Escriba un programa que lea 11 números, divida la suma de los 10 primeros números entre el undécimo número y muestre el resultado.
por el undécimo número y muestre el resultado. (b) Enumera todas las preguntas que te surgieron en el
proceso de programación de la parte (a) de esta pregunta. (c) Comente, en su opinión, qué tipo de
de habilidades son necesarias para recopilar y especificar los requisitos de un sistema.
6. Discuta las tres áreas que deben coordinarse en un gran proyecto de ingeniería de software.
de software. ¿Es alguna de ellas más importante que las demás? Explique su conclusión.
